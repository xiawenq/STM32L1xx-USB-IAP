; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_sdio.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_sdio.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\utility -I..\User\inc -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I"E:\my code\IAP\DFU-STM32L15X\MDK-ARM\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32L1xx_DFP\1.0.2\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\stm32l1xx_sdio.crf ..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_sdio.c]
                          THUMB

                          AREA ||i.SDIO_CEATAITCmd||, CODE, READONLY, ALIGN=2

                  SDIO_CEATAITCmd PROC
;;;730      */
;;;731    void SDIO_CEATAITCmd(FunctionalState NewState)
000000  2101              MOVS     r1,#1
;;;732    { 
;;;733      /* Check the parameters */
;;;734      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;735      
;;;736      *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
000002  4381              BICS     r1,r1,r0
000004  4801              LDR      r0,|L1.12|
000006  f8c011b4          STR      r1,[r0,#0x1b4]
;;;737    }
00000a  4770              BX       lr
;;;738    
                          ENDP

                  |L1.12|
                          DCD      0x42258000

                          AREA ||i.SDIO_ClearFlag||, CODE, READONLY, ALIGN=2

                  SDIO_ClearFlag PROC
;;;888      */
;;;889    void SDIO_ClearFlag(uint32_t SDIO_FLAG)
000000  4901              LDR      r1,|L2.8|
;;;890    { 
;;;891      /* Check the parameters */
;;;892      assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
;;;893       
;;;894      SDIO->ICR = SDIO_FLAG;
000002  6008              STR      r0,[r1,#0]
;;;895    }
000004  4770              BX       lr
;;;896    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      0x40012c38

                          AREA ||i.SDIO_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  SDIO_ClearITPendingBit PROC
;;;963      */
;;;964    void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
000000  4901              LDR      r1,|L3.8|
;;;965    { 
;;;966      /* Check the parameters */
;;;967      assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
;;;968       
;;;969      SDIO->ICR = SDIO_IT;
000002  6008              STR      r0,[r1,#0]
;;;970    }
000004  4770              BX       lr
;;;971    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x40012c38

                          AREA ||i.SDIO_ClockCmd||, CODE, READONLY, ALIGN=2

                  SDIO_ClockCmd PROC
;;;314      */
;;;315    void SDIO_ClockCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L4.8|
;;;316    {
;;;317      /* Check the parameters */
;;;318      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;319      
;;;320      *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
000002  f8c100a0          STR      r0,[r1,#0xa0]
;;;321    }
000006  4770              BX       lr
;;;322    
                          ENDP

                  |L4.8|
                          DCD      0x42258000

                          AREA ||i.SDIO_CmdStructInit||, CODE, READONLY, ALIGN=1

                  SDIO_CmdStructInit PROC
;;;444      */
;;;445    void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
000000  2100              MOVS     r1,#0
;;;446    {
;;;447      /* SDIO_CmdInitStruct members default value */
;;;448      SDIO_CmdInitStruct->SDIO_Argument = 0x00;
;;;449      SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
000002  6001              STR      r1,[r0,#0]
;;;450      SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
000004  6041              STR      r1,[r0,#4]
;;;451      SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
000006  6081              STR      r1,[r0,#8]
;;;452      SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
000008  60c1              STR      r1,[r0,#0xc]
00000a  6101              STR      r1,[r0,#0x10]
;;;453    }
00000c  4770              BX       lr
;;;454    
                          ENDP


                          AREA ||i.SDIO_CommandCompletionCmd||, CODE, READONLY, ALIGN=2

                  SDIO_CommandCompletionCmd PROC
;;;717      */
;;;718    void SDIO_CommandCompletionCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L6.8|
;;;719    { 
;;;720      /* Check the parameters */
;;;721      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;722      
;;;723      *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
000002  f8c101b0          STR      r0,[r1,#0x1b0]
;;;724    }
000006  4770              BX       lr
;;;725    
                          ENDP

                  |L6.8|
                          DCD      0x42258000

                          AREA ||i.SDIO_DMACmd||, CODE, READONLY, ALIGN=2

                  SDIO_DMACmd PROC
;;;375      */
;;;376    void SDIO_DMACmd(FunctionalState NewState)
000000  4901              LDR      r1,|L7.8|
;;;377    {
;;;378      /* Check the parameters */
;;;379      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;380      
;;;381      *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;382    }
000004  4770              BX       lr
;;;383    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x4225858c

                          AREA ||i.SDIO_DataConfig||, CODE, READONLY, ALIGN=2

                  SDIO_DataConfig PROC
;;;511      */
;;;512    void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
000000  b510              PUSH     {r4,lr}
;;;513    {
;;;514      uint32_t tmpreg = 0;
;;;515      
;;;516      /* Check the parameters */
;;;517      assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));
;;;518      assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));
;;;519      assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));
;;;520      assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
;;;521      assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));
;;;522    
;;;523    /*---------------------------- SDIO DTIMER Configuration ---------------------*/
;;;524      /* Set the SDIO Data TimeOut value */
;;;525      SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
000002  4a0a              LDR      r2,|L8.44|
000004  6801              LDR      r1,[r0,#0]
000006  6011              STR      r1,[r2,#0]
;;;526    
;;;527    /*---------------------------- SDIO DLEN Configuration -----------------------*/
;;;528      /* Set the SDIO DataLength value */
;;;529      SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
000008  1d12              ADDS     r2,r2,#4
00000a  6841              LDR      r1,[r0,#4]
00000c  6011              STR      r1,[r2,#0]
;;;530    
;;;531    /*---------------------------- SDIO DCTRL Configuration ----------------------*/  
;;;532      /* Get the SDIO DCTRL value */
;;;533      tmpreg = SDIO->DCTRL;
00000e  1d12              ADDS     r2,r2,#4
000010  6811              LDR      r1,[r2,#0]
;;;534      /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
;;;535      tmpreg &= DCTRL_CLEAR_MASK;
000012  f02103f7          BIC      r3,r1,#0xf7
000016  e9d01402          LDRD     r1,r4,[r0,#8]
;;;536      /* Set DEN bit according to SDIO_DPSM value */
;;;537      /* Set DTMODE bit according to SDIO_TransferMode value */
;;;538      /* Set DTDIR bit according to SDIO_TransferDir value */
;;;539      /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
;;;540      tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
00001a  4321              ORRS     r1,r1,r4
00001c  e9d04004          LDRD     r4,r0,[r0,#0x10]
000020  4304              ORRS     r4,r4,r0
000022  4321              ORRS     r1,r1,r4
000024  4319              ORRS     r1,r1,r3
;;;541               | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
;;;542    
;;;543      /* Write to SDIO DCTRL */
;;;544      SDIO->DCTRL = tmpreg;
000026  6011              STR      r1,[r2,#0]
;;;545    }
000028  bd10              POP      {r4,pc}
;;;546    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40012c24

                          AREA ||i.SDIO_DataStructInit||, CODE, READONLY, ALIGN=1

                  SDIO_DataStructInit PROC
;;;552      */
;;;553    void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;554    {
;;;555      /* SDIO_DataInitStruct members default value */
;;;556      SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
;;;557      SDIO_DataInitStruct->SDIO_DataLength = 0x00;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
;;;558      SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
000008  6041              STR      r1,[r0,#4]
;;;559      SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
00000a  6081              STR      r1,[r0,#8]
;;;560      SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
00000c  60c1              STR      r1,[r0,#0xc]
;;;561      SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
00000e  6101              STR      r1,[r0,#0x10]
000010  6141              STR      r1,[r0,#0x14]
;;;562    }
000012  4770              BX       lr
;;;563    
                          ENDP


                          AREA ||i.SDIO_DeInit||, CODE, READONLY, ALIGN=1

                  SDIO_DeInit PROC
;;;247      */
;;;248    void SDIO_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;249    {
;;;250      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
000002  2101              MOVS     r1,#1
000004  02cc              LSLS     r4,r1,#11
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;251      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);  
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
;;;252    }
;;;253    
                          ENDP


                          AREA ||i.SDIO_GetCommandResponse||, CODE, READONLY, ALIGN=2

                  SDIO_GetCommandResponse PROC
;;;459      */
;;;460    uint8_t SDIO_GetCommandResponse(void)
000000  4801              LDR      r0,|L11.8|
;;;461    {
;;;462      return (uint8_t)(SDIO->RESPCMD);
000002  6800              LDR      r0,[r0,#0]
000004  b2c0              UXTB     r0,r0
;;;463    }
000006  4770              BX       lr
;;;464    
                          ENDP

                  |L11.8|
                          DCD      0x40012c10

                          AREA ||i.SDIO_GetDataCounter||, CODE, READONLY, ALIGN=2

                  SDIO_GetDataCounter PROC
;;;568      */
;;;569    uint32_t SDIO_GetDataCounter(void)
000000  4801              LDR      r0,|L12.8|
;;;570    { 
;;;571      return SDIO->DCOUNT;
000002  6800              LDR      r0,[r0,#0]
;;;572    }
000004  4770              BX       lr
;;;573    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40012c30

                          AREA ||i.SDIO_GetFIFOCount||, CODE, READONLY, ALIGN=2

                  SDIO_GetFIFOCount PROC
;;;598      */
;;;599    uint32_t SDIO_GetFIFOCount(void)
000000  4801              LDR      r0,|L13.8|
;;;600    { 
;;;601      return SDIO->FIFOCNT;
000002  6800              LDR      r0,[r0,#0]
;;;602    }
000004  4770              BX       lr
;;;603    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40012c48

                          AREA ||i.SDIO_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  SDIO_GetFlagStatus PROC
;;;850      */
;;;851    FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)
000000  4a03              LDR      r2,|L14.16|
;;;852    { 
000002  4601              MOV      r1,r0
;;;853      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;854      
;;;855      /* Check the parameters */
;;;856      assert_param(IS_SDIO_FLAG(SDIO_FLAG));
;;;857      
;;;858      if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L14.14|
;;;859      {
;;;860        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L14.14|
;;;861      }
;;;862      else
;;;863      {
;;;864        bitstatus = RESET;
;;;865      }
;;;866      return bitstatus;
;;;867    }
00000e  4770              BX       lr
;;;868    
                          ENDP

                  |L14.16|
                          DCD      0x40012c34

                          AREA ||i.SDIO_GetITStatus||, CODE, READONLY, ALIGN=2

                  SDIO_GetITStatus PROC
;;;927      */
;;;928    ITStatus SDIO_GetITStatus(uint32_t SDIO_IT)
000000  4a03              LDR      r2,|L15.16|
;;;929    { 
000002  4601              MOV      r1,r0
;;;930      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;931      
;;;932      /* Check the parameters */
;;;933      assert_param(IS_SDIO_GET_IT(SDIO_IT));
;;;934      if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L15.14|
;;;935      {
;;;936        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L15.14|
;;;937      }
;;;938      else
;;;939      {
;;;940        bitstatus = RESET;
;;;941      }
;;;942      return bitstatus;
;;;943    }
00000e  4770              BX       lr
;;;944    
                          ENDP

                  |L15.16|
                          DCD      0x40012c34

                          AREA ||i.SDIO_GetPowerState||, CODE, READONLY, ALIGN=2

                  SDIO_GetPowerState PROC
;;;347      */
;;;348    uint32_t SDIO_GetPowerState(void)
000000  4802              LDR      r0,|L16.12|
;;;349    {
;;;350      return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
000002  6800              LDR      r0,[r0,#0]
000004  f0000003          AND      r0,r0,#3
;;;351    }
000008  4770              BX       lr
;;;352    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40012c00

                          AREA ||i.SDIO_GetResponse||, CODE, READONLY, ALIGN=2

                  SDIO_GetResponse PROC
;;;474      */
;;;475    uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
000000  b508              PUSH     {r3,lr}
;;;476    {
;;;477      __IO uint32_t tmp = 0;
;;;478    
;;;479      /* Check the parameters */
;;;480      assert_param(IS_SDIO_RESP(SDIO_RESP));
;;;481    
;;;482      tmp = SDIO_RESP_ADDR + SDIO_RESP;
000002  4902              LDR      r1,|L17.12|
000004  4408              ADD      r0,r0,r1
;;;483      
;;;484      return (*(__IO uint32_t *) tmp); 
000006  9000              STR      r0,[sp,#0]
000008  6800              LDR      r0,[r0,#0]
;;;485    }
00000a  bd08              POP      {r3,pc}
;;;486    
                          ENDP

                  |L17.12|
                          DCD      0x40012c14

                          AREA ||i.SDIO_ITConfig||, CODE, READONLY, ALIGN=2

                  SDIO_ITConfig PROC
;;;801      */
;;;802    void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L18.20|
;;;803    {
;;;804      /* Check the parameters */
;;;805      assert_param(IS_SDIO_IT(SDIO_IT));
;;;806      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;807      
;;;808      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;809      {
;;;810        /* Enable the SDIO interrupts */
;;;811        SDIO->MASK |= SDIO_IT;
;;;812      }
;;;813      else
;;;814      {
;;;815        /* Disable the SDIO interrupts */
;;;816        SDIO->MASK &= ~SDIO_IT;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L18.12|
000008  4301              ORRS     r1,r1,r0              ;811
00000a  e000              B        |L18.14|
                  |L18.12|
00000c  4381              BICS     r1,r1,r0
                  |L18.14|
00000e  6011              STR      r1,[r2,#0]            ;811
;;;817      } 
;;;818    }
000010  4770              BX       lr
;;;819    
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      0x40012c3c

                          AREA ||i.SDIO_Init||, CODE, READONLY, ALIGN=2

                  SDIO_Init PROC
;;;260      */
;;;261    void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;262    {
;;;263      uint32_t tmpreg = 0;
;;;264        
;;;265      /* Check the parameters */
;;;266      assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));
;;;267      assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));
;;;268      assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));
;;;269      assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
;;;270      assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
;;;271       
;;;272    /*---------------------------- SDIO CLKCR Configuration ------------------------*/  
;;;273      /* Get the SDIO CLKCR value */
;;;274      tmpreg = SDIO->CLKCR;
000002  4b09              LDR      r3,|L19.40|
000004  681a              LDR      r2,[r3,#0]
;;;275      
;;;276      /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
;;;277      tmpreg &= CLKCR_CLEAR_MASK;
000006  f64761ff          MOV      r1,#0x7eff
00000a  438a              BICS     r2,r2,r1
;;;278      
;;;279      /* Set CLKDIV bits according to SDIO_ClockDiv value */
;;;280      /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
;;;281      /* Set BYPASS bit according to SDIO_ClockBypass value */
;;;282      /* Set WIDBUS bits according to SDIO_BusWide value */
;;;283      /* Set NEGEDGE bits according to SDIO_ClockEdge value */
;;;284      /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
;;;285      tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
00000c  7d01              LDRB     r1,[r0,#0x14]
00000e  6884              LDR      r4,[r0,#8]
000010  68c5              LDR      r5,[r0,#0xc]
000012  4321              ORRS     r1,r1,r4
000014  6844              LDR      r4,[r0,#4]
000016  432c              ORRS     r4,r4,r5
000018  4321              ORRS     r1,r1,r4
00001a  6804              LDR      r4,[r0,#0]
00001c  6900              LDR      r0,[r0,#0x10]
00001e  4321              ORRS     r1,r1,r4
000020  4301              ORRS     r1,r1,r0
000022  4311              ORRS     r1,r1,r2
;;;286                 SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
;;;287                 SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
;;;288      
;;;289      /* Write to SDIO CLKCR */
;;;290      SDIO->CLKCR = tmpreg;
000024  6019              STR      r1,[r3,#0]
;;;291    }
000026  bd30              POP      {r4,r5,pc}
;;;292    
                          ENDP

                  |L19.40|
                          DCD      0x40012c04

                          AREA ||i.SDIO_ReadData||, CODE, READONLY, ALIGN=2

                  SDIO_ReadData PROC
;;;578      */
;;;579    uint32_t SDIO_ReadData(void)
000000  4801              LDR      r0,|L20.8|
;;;580    { 
;;;581      return SDIO->FIFO;
000002  6800              LDR      r0,[r0,#0]
;;;582    }
000004  4770              BX       lr
;;;583    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x40012c80

                          AREA ||i.SDIO_SendCEATACmd||, CODE, READONLY, ALIGN=2

                  SDIO_SendCEATACmd PROC
;;;743      */
;;;744    void SDIO_SendCEATACmd(FunctionalState NewState)
000000  4901              LDR      r1,|L21.8|
;;;745    { 
;;;746      /* Check the parameters */
;;;747      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;748      
;;;749      *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
000002  f8c101b8          STR      r0,[r1,#0x1b8]
;;;750    }
000006  4770              BX       lr
;;;751    
                          ENDP

                  |L21.8|
                          DCD      0x42258000

                          AREA ||i.SDIO_SendCommand||, CODE, READONLY, ALIGN=2

                  SDIO_SendCommand PROC
;;;408      */
;;;409    void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
000000  b510              PUSH     {r4,lr}
;;;410    {
;;;411      uint32_t tmpreg = 0;
;;;412      
;;;413      /* Check the parameters */
;;;414      assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));
;;;415      assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));
;;;416      assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
;;;417      assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
;;;418      
;;;419    /*---------------------------- SDIO ARG Configuration ------------------------*/
;;;420      /* Set the SDIO Argument value */
;;;421      SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
000002  4a08              LDR      r2,|L22.36|
000004  6801              LDR      r1,[r0,#0]
000006  6011              STR      r1,[r2,#0]
;;;422      
;;;423    /*---------------------------- SDIO CMD Configuration ------------------------*/  
;;;424      /* Get the SDIO CMD value */
;;;425      tmpreg = SDIO->CMD;
000008  1d12              ADDS     r2,r2,#4
00000a  6811              LDR      r1,[r2,#0]
;;;426      /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
;;;427      tmpreg &= CMD_CLEAR_MASK;
00000c  0acb              LSRS     r3,r1,#11
00000e  e9d01401          LDRD     r1,r4,[r0,#4]
;;;428      /* Set CMDINDEX bits according to SDIO_CmdIndex value */
;;;429      /* Set WAITRESP bits according to SDIO_Response value */
;;;430      /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
;;;431      /* Set CPSMEN bits according to SDIO_CPSM value */
;;;432      tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
000012  4321              ORRS     r1,r1,r4
000014  e9d04003          LDRD     r4,r0,[r0,#0xc]
000018  4304              ORRS     r4,r4,r0
00001a  02db              LSLS     r3,r3,#11             ;427
00001c  4321              ORRS     r1,r1,r4
00001e  4319              ORRS     r1,r1,r3
;;;433               | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
;;;434      
;;;435      /* Write to SDIO CMD */
;;;436      SDIO->CMD = tmpreg;
000020  6011              STR      r1,[r2,#0]
;;;437    }
000022  bd10              POP      {r4,pc}
;;;438    
                          ENDP

                  |L22.36|
                          DCD      0x40012c08

                          AREA ||i.SDIO_SendSDIOSuspendCmd||, CODE, READONLY, ALIGN=2

                  SDIO_SendSDIOSuspendCmd PROC
;;;685      */
;;;686    void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L23.8|
;;;687    { 
;;;688      /* Check the parameters */
;;;689      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;690      
;;;691      *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
000002  f8c101ac          STR      r0,[r1,#0x1ac]
;;;692    }
000006  4770              BX       lr
;;;693    
                          ENDP

                  |L23.8|
                          DCD      0x42258000

                          AREA ||i.SDIO_SetPowerState||, CODE, READONLY, ALIGN=2

                  SDIO_SetPowerState PROC
;;;330      */
;;;331    void SDIO_SetPowerState(uint32_t SDIO_PowerState)
000000  4901              LDR      r1,|L24.8|
;;;332    {
;;;333      /* Check the parameters */
;;;334      assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
;;;335    
;;;336      SDIO->POWER = SDIO_PowerState;
000002  6008              STR      r0,[r1,#0]
;;;337    }
000004  4770              BX       lr
;;;338    
                          ENDP

000006  0000              DCW      0x0000
                  |L24.8|
                          DCD      0x40012c00

                          AREA ||i.SDIO_SetSDIOOperation||, CODE, READONLY, ALIGN=2

                  SDIO_SetSDIOOperation PROC
;;;671      */
;;;672    void SDIO_SetSDIOOperation(FunctionalState NewState)
000000  4901              LDR      r1,|L25.8|
;;;673    { 
;;;674      /* Check the parameters */
;;;675      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;676      
;;;677      *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;678    }
000004  4770              BX       lr
;;;679    
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      0x422585ac

                          AREA ||i.SDIO_SetSDIOReadWaitMode||, CODE, READONLY, ALIGN=2

                  SDIO_SetSDIOReadWaitMode PROC
;;;657      */
;;;658    void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
000000  4901              LDR      r1,|L26.8|
;;;659    {
;;;660      /* Check the parameters */
;;;661      assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
;;;662      
;;;663      *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
000002  6008              STR      r0,[r1,#0]
;;;664    }
000004  4770              BX       lr
;;;665    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x422585a8

                          AREA ||i.SDIO_StartSDIOReadWait||, CODE, READONLY, ALIGN=2

                  SDIO_StartSDIOReadWait PROC
;;;627      */
;;;628    void SDIO_StartSDIOReadWait(FunctionalState NewState)
000000  4901              LDR      r1,|L27.8|
;;;629    { 
;;;630      /* Check the parameters */
;;;631      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;632      
;;;633      *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;634    }
000004  4770              BX       lr
;;;635    
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x422585a0

                          AREA ||i.SDIO_StopSDIOReadWait||, CODE, READONLY, ALIGN=2

                  SDIO_StopSDIOReadWait PROC
;;;641      */
;;;642    void SDIO_StopSDIOReadWait(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;643    { 
;;;644      /* Check the parameters */
;;;645      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;646      
;;;647      *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;648    }
000004  4770              BX       lr
;;;649    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x422585a4

                          AREA ||i.SDIO_StructInit||, CODE, READONLY, ALIGN=1

                  SDIO_StructInit PROC
;;;298      */
;;;299    void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
000000  2100              MOVS     r1,#0
;;;300    {
;;;301      /* SDIO_InitStruct members default value */
;;;302      SDIO_InitStruct->SDIO_ClockDiv = 0x00;
000002  7501              STRB     r1,[r0,#0x14]
;;;303      SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
;;;304      SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
000004  6001              STR      r1,[r0,#0]
;;;305      SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
000006  6041              STR      r1,[r0,#4]
;;;306      SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
000008  6081              STR      r1,[r0,#8]
;;;307      SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
00000a  60c1              STR      r1,[r0,#0xc]
00000c  6101              STR      r1,[r0,#0x10]
;;;308    }
00000e  4770              BX       lr
;;;309    
                          ENDP


                          AREA ||i.SDIO_WriteData||, CODE, READONLY, ALIGN=2

                  SDIO_WriteData PROC
;;;588      */
;;;589    void SDIO_WriteData(uint32_t Data)
000000  4901              LDR      r1,|L30.8|
;;;590    { 
;;;591      SDIO->FIFO = Data;
000002  6008              STR      r0,[r1,#0]
;;;592    }
000004  4770              BX       lr
;;;593    
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      0x40012c80

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_sdio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32l1xx_sdio_c_c8827541____REV16|
#line 114 "..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32l1xx_sdio_c_c8827541____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32l1xx_sdio_c_c8827541____REVSH|
#line 128
|__asm___16_stm32l1xx_sdio_c_c8827541____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
