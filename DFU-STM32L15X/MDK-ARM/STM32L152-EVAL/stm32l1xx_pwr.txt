; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_pwr.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_pwr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\utility -I..\User\inc -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I"E:\my code\IAP\DFU-STM32L15X\MDK-ARM\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32L1xx_DFP\1.0.2\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\stm32l1xx_pwr.crf ..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_pwr.c]
                          THUMB

                          AREA ||i.PWR_ClearFlag||, CODE, READONLY, ALIGN=2

                  PWR_ClearFlag PROC
;;;808      */
;;;809    void PWR_ClearFlag(uint32_t PWR_FLAG)
000000  4902              LDR      r1,|L1.12|
;;;810    {
;;;811      /* Check the parameters */
;;;812      assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
;;;813             
;;;814      PWR->CR |=  PWR_FLAG << 2;
000002  680a              LDR      r2,[r1,#0]
000004  ea420080          ORR      r0,r2,r0,LSL #2
000008  6008              STR      r0,[r1,#0]
;;;815    }
00000a  4770              BX       lr
;;;816    
                          ENDP

                  |L1.12|
                          DCD      0x40007000

                          AREA ||i.PWR_DeInit||, CODE, READONLY, ALIGN=1

                  PWR_DeInit PROC
;;;122      */
;;;123    void PWR_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;124    {
;;;125      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  070c              LSLS     r4,r1,#28
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;126      RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;127    }
;;;128    
                          ENDP


                          AREA ||i.PWR_EnterLowPowerRunMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterLowPowerRunMode PROC
;;;586      */
;;;587    void PWR_EnterLowPowerRunMode(FunctionalState NewState)
000000  4909              LDR      r1,|L3.40|
;;;588    {
;;;589      /* Check the parameters */
;;;590      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;591    
;;;592      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;593      {
;;;594        PWR->CR |= PWR_CR_LPSDSR;
;;;595        PWR->CR |= PWR_CR_LPRUN;     
;;;596      }
;;;597      else
;;;598      {
;;;599        PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_LPRUN); 
000004  6808              LDR      r0,[r1,#0]
000006  d006              BEQ      |L3.22|
000008  f0400001          ORR      r0,r0,#1              ;594
00000c  6008              STR      r0,[r1,#0]            ;594
00000e  6808              LDR      r0,[r1,#0]            ;595
000010  f4404080          ORR      r0,r0,#0x4000         ;595
000014  e005              B        |L3.34|
                  |L3.22|
000016  f4204080          BIC      r0,r0,#0x4000
00001a  6008              STR      r0,[r1,#0]
;;;600        PWR->CR &= (uint32_t)~((uint32_t)PWR_CR_LPSDSR);  
00001c  6808              LDR      r0,[r1,#0]
00001e  f0200001          BIC      r0,r0,#1
                  |L3.34|
000022  6008              STR      r0,[r1,#0]            ;595
;;;601      }  
;;;602    }
000024  4770              BX       lr
;;;603    
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40007000

                          AREA ||i.PWR_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTANDBYMode PROC
;;;722      */
;;;723    void PWR_EnterSTANDBYMode(void)
000000  4807              LDR      r0,|L4.32|
;;;724    {
;;;725      /* Clear Wakeup flag */
;;;726      PWR->CR |= PWR_CR_CWUF;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;727      
;;;728      /* Select STANDBY mode */
;;;729      PWR->CR |= PWR_CR_PDDS;
00000a  6801              LDR      r1,[r0,#0]
00000c  f0410102          ORR      r1,r1,#2
000010  6001              STR      r1,[r0,#0]
;;;730      
;;;731      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;732      SCB->SCR |= SCB_SCR_SLEEPDEEP;
000012  4804              LDR      r0,|L4.36|
000014  6801              LDR      r1,[r0,#0]
000016  f0410104          ORR      r1,r1,#4
00001a  6001              STR      r1,[r0,#0]
;;;733      
;;;734    /* This option is used to ensure that store operations are completed */
;;;735    #if defined ( __CC_ARM   )
;;;736      __force_stores();
;;;737    #endif
;;;738      /* Request Wait For Interrupt */
;;;739      __WFI();
00001c  bf30              WFI      
;;;740    }
00001e  4770              BX       lr
;;;741    
                          ENDP

                  |L4.32|
                          DCD      0x40007000
                  |L4.36|
                          DCD      0xe000ed10

                          AREA ||i.PWR_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSTOPMode PROC
;;;675      */
;;;676    void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
000000  4b0a              LDR      r3,|L5.44|
;;;677    {
;;;678      uint32_t tmpreg = 0;
;;;679      
;;;680      /* Check the parameters */
;;;681      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
;;;682      assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
;;;683      
;;;684      /* Select the regulator state in STOP mode ---------------------------------*/
;;;685      tmpreg = PWR->CR;
000002  681a              LDR      r2,[r3,#0]
;;;686      /* Clear PDDS and LPDSR bits */
;;;687      tmpreg &= CR_DS_MASK;
000004  f0220203          BIC      r2,r2,#3
;;;688      
;;;689      /* Set LPDSR bit according to PWR_Regulator value */
;;;690      tmpreg |= PWR_Regulator;
000008  4302              ORRS     r2,r2,r0
;;;691      
;;;692      /* Store the new value */
;;;693      PWR->CR = tmpreg;
00000a  601a              STR      r2,[r3,#0]
;;;694      
;;;695      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;696      SCB->SCR |= SCB_SCR_SLEEPDEEP;
00000c  4808              LDR      r0,|L5.48|
00000e  6802              LDR      r2,[r0,#0]
000010  f0420204          ORR      r2,r2,#4
000014  6002              STR      r2,[r0,#0]
;;;697      
;;;698      /* Select STOP mode entry --------------------------------------------------*/
;;;699      if(PWR_STOPEntry == PWR_STOPEntry_WFI)
000016  2901              CMP      r1,#1
000018  d005              BEQ      |L5.38|
;;;700      {   
;;;701        /* Request Wait For Interrupt */
;;;702        __WFI();
;;;703      }
;;;704      else
;;;705      {
;;;706        /* Request Wait For Event */
;;;707        __WFE();
00001a  bf20              WFE      
                  |L5.28|
;;;708      }
;;;709      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;710      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);  
00001c  6801              LDR      r1,[r0,#0]
00001e  f0210104          BIC      r1,r1,#4
000022  6001              STR      r1,[r0,#0]
;;;711    }
000024  4770              BX       lr
                  |L5.38|
000026  bf30              WFI                            ;702
000028  e7f8              B        |L5.28|
;;;712    
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0x40007000
                  |L5.48|
                          DCD      0xe000ed10

                          AREA ||i.PWR_EnterSleepMode||, CODE, READONLY, ALIGN=2

                  PWR_EnterSleepMode PROC
;;;619      */
;;;620    void PWR_EnterSleepMode(uint32_t PWR_Regulator, uint8_t PWR_SLEEPEntry)
000000  4b08              LDR      r3,|L6.36|
;;;621    {
;;;622      uint32_t tmpreg = 0;
;;;623    
;;;624      /* Check the parameters */
;;;625      assert_param(IS_PWR_REGULATOR(PWR_Regulator));
;;;626    
;;;627      assert_param(IS_PWR_SLEEP_ENTRY(PWR_SLEEPEntry));
;;;628      
;;;629      /* Select the regulator state in Sleep mode ---------------------------------*/
;;;630      tmpreg = PWR->CR;
000002  681a              LDR      r2,[r3,#0]
;;;631      
;;;632      /* Clear PDDS and LPDSR bits */
;;;633      tmpreg &= CR_DS_MASK;
000004  f0220203          BIC      r2,r2,#3
;;;634      
;;;635      /* Set LPDSR bit according to PWR_Regulator value */
;;;636      tmpreg |= PWR_Regulator;
000008  4302              ORRS     r2,r2,r0
;;;637      
;;;638      /* Store the new value */
;;;639      PWR->CR = tmpreg;
00000a  601a              STR      r2,[r3,#0]
;;;640    
;;;641      /* Clear SLEEPDEEP bit of Cortex System Control Register */
;;;642      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
00000c  4806              LDR      r0,|L6.40|
00000e  6802              LDR      r2,[r0,#0]
000010  f0220204          BIC      r2,r2,#4
000014  6002              STR      r2,[r0,#0]
;;;643      
;;;644      /* Select SLEEP mode entry -------------------------------------------------*/
;;;645      if(PWR_SLEEPEntry == PWR_SLEEPEntry_WFI)
000016  2901              CMP      r1,#1
000018  d001              BEQ      |L6.30|
;;;646      {   
;;;647        /* Request Wait For Interrupt */
;;;648        __WFI();
;;;649      }
;;;650      else
;;;651      {
;;;652        /* Request Wait For Event */
;;;653        __WFE();
00001a  bf20              WFE      
;;;654      }
;;;655    }
00001c  4770              BX       lr
                  |L6.30|
00001e  bf30              WFI                            ;648
000020  4770              BX       lr
;;;656    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x40007000
                  |L6.40|
                          DCD      0xe000ed10

                          AREA ||i.PWR_FastWakeUpCmd||, CODE, READONLY, ALIGN=2

                  PWR_FastWakeUpCmd PROC
;;;293      */
;;;294    void PWR_FastWakeUpCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L7.8|
;;;295    {
;;;296      /* Check the parameters */
;;;297      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;298    
;;;299      *(__IO uint32_t *) CR_FWU_BB = (uint32_t)NewState;
000002  6288              STR      r0,[r1,#0x28]
;;;300    }
000004  4770              BX       lr
;;;301    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  PWR_GetFlagStatus PROC
;;;782      */
;;;783    FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
000000  4a03              LDR      r2,|L8.16|
;;;784    {
000002  4601              MOV      r1,r0
;;;785      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;786      /* Check the parameters */
;;;787      assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
;;;788      
;;;789      if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
000006  6852              LDR      r2,[r2,#4]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L8.14|
;;;790      {
;;;791        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L8.14|
;;;792      }
;;;793      else
;;;794      {
;;;795        bitstatus = RESET;
;;;796      }
;;;797      /* Return the flag status */
;;;798      return bitstatus;
;;;799    }
00000e  4770              BX       lr
;;;800    
                          ENDP

                  |L8.16|
                          DCD      0x40007000

                          AREA ||i.PWR_PVDCmd||, CODE, READONLY, ALIGN=2

                  PWR_PVDCmd PROC
;;;209      */
;;;210    void PWR_PVDCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L9.8|
;;;211    {
;;;212      /* Check the parameters */
;;;213      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;214      
;;;215      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
000002  6108              STR      r0,[r1,#0x10]
;;;216    }
000004  4770              BX       lr
;;;217    
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_PVDLevelConfig||, CODE, READONLY, ALIGN=2

                  PWR_PVDLevelConfig PROC
;;;184      */
;;;185    void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
000000  4a03              LDR      r2,|L10.16|
;;;186    {
;;;187      uint32_t tmpreg = 0;
;;;188      
;;;189      /* Check the parameters */
;;;190      assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
;;;191      
;;;192      tmpreg = PWR->CR;
000002  6811              LDR      r1,[r2,#0]
;;;193      
;;;194      /* Clear PLS[7:5] bits */
;;;195      tmpreg &= CR_PLS_MASK;
000004  f02101e0          BIC      r1,r1,#0xe0
;;;196      
;;;197      /* Set PLS[7:5] bits according to PWR_PVDLevel value */
;;;198      tmpreg |= PWR_PVDLevel;
000008  4301              ORRS     r1,r1,r0
;;;199      
;;;200      /* Store the new value */
;;;201      PWR->CR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;202    }
00000c  4770              BX       lr
;;;203    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0x40007000

                          AREA ||i.PWR_RTCAccessCmd||, CODE, READONLY, ALIGN=2

                  PWR_RTCAccessCmd PROC
;;;136      */
;;;137    void PWR_RTCAccessCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;138    {
;;;139      /* Check the parameters */
;;;140      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;141      
;;;142      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
000002  6208              STR      r0,[r1,#0x20]
;;;143    }
000004  4770              BX       lr
;;;144    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_UltraLowPowerCmd||, CODE, READONLY, ALIGN=2

                  PWR_UltraLowPowerCmd PROC
;;;307      */
;;;308    void PWR_UltraLowPowerCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L12.8|
;;;309    {
;;;310      /* Check the parameters */
;;;311      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;312    
;;;313      *(__IO uint32_t *) CR_ULP_BB = (uint32_t)NewState;
000002  6248              STR      r0,[r1,#0x24]
;;;314    }
000004  4770              BX       lr
;;;315    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x420e0000

                          AREA ||i.PWR_VoltageScalingConfig||, CODE, READONLY, ALIGN=2

                  PWR_VoltageScalingConfig PROC
;;;404      */
;;;405    void PWR_VoltageScalingConfig(uint32_t PWR_VoltageScaling)
000000  4a04              LDR      r2,|L13.20|
;;;406    {
;;;407      uint32_t tmp = 0;
;;;408      
;;;409      /* Check the parameters */
;;;410      assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(PWR_VoltageScaling));
;;;411      
;;;412      tmp = PWR->CR;
000002  6811              LDR      r1,[r2,#0]
;;;413    
;;;414      tmp &= CR_VOS_MASK;
000004  f42151c0          BIC      r1,r1,#0x1800
;;;415      tmp |= PWR_VoltageScaling;
000008  4301              ORRS     r1,r1,r0
;;;416      
;;;417      PWR->CR = tmp & 0xFFFFFFF3;
00000a  f021000c          BIC      r0,r1,#0xc
00000e  6010              STR      r0,[r2,#0]
;;;418    
;;;419    }
000010  4770              BX       lr
;;;420    
                          ENDP

000012  0000              DCW      0x0000
                  |L13.20|
                          DCD      0x40007000

                          AREA ||i.PWR_WakeUpPinCmd||, CODE, READONLY, ALIGN=2

                  PWR_WakeUpPinCmd PROC
;;;246      */
;;;247    void PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPin, FunctionalState NewState)
000000  b508              PUSH     {r3,lr}
;;;248    {
;;;249      __IO uint32_t tmp = 0;
;;;250      
;;;251      /* Check the parameters */
;;;252      assert_param(IS_PWR_WAKEUP_PIN(PWR_WakeUpPin));
;;;253      
;;;254      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;255    
;;;256      tmp = CSR_EWUP_BB + PWR_WakeUpPin;
000002  4a02              LDR      r2,|L14.12|
000004  4410              ADD      r0,r0,r2
;;;257      
;;;258      *(__IO uint32_t *) (tmp) = (uint32_t)NewState;
000006  9000              STR      r0,[sp,#0]
000008  6001              STR      r1,[r0,#0]
;;;259    }
00000a  bd08              POP      {r3,pc}
;;;260    
                          ENDP

                  |L14.12|
                          DCD      0x420e00a0

;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_pwr_c_0c2a8b75____REV16|
#line 114 "..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32l1xx_pwr_c_0c2a8b75____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_pwr_c_0c2a8b75____REVSH|
#line 128
|__asm___15_stm32l1xx_pwr_c_0c2a8b75____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
