; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\hw_config.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\utility -I..\User\inc -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I"E:\my code\IAP\DFU-STM32L15X\MDK-ARM\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32L1xx_DFP\1.0.2\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\hw_config.crf ..\User\src\hw_config.c]
                          THUMB

                          AREA ||i.DFU_Button_Config||, CODE, READONLY, ALIGN=2

                  DFU_Button_Config PROC
;;;162    *******************************************************************************/
;;;163    void DFU_Button_Config(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;164    {  
;;;165    	GPIO_InitTypeDef GPIO_InitStructure;
;;;166    
;;;167    	/* Enable the BUTTON Clock */
;;;168    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;169    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;170    
;;;171    	/* Configure Button pin as input */
;;;172    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
000012  2000              MOVS     r0,#0
000014  f88d0004          STRB     r0,[sp,#4]
;;;173    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
000018  2001              MOVS     r0,#1
00001a  f88d0007          STRB     r0,[sp,#7]
;;;174    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
00001e  0340              LSLS     r0,r0,#13
;;;175    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000020  9000              STR      r0,[sp,#0]
000022  4669              MOV      r1,sp
000024  4801              LDR      r0,|L1.44|
000026  f7fffffe          BL       GPIO_Init
;;;176    }
00002a  bd1c              POP      {r2-r4,pc}
;;;177    
                          ENDP

                  |L1.44|
                          DCD      0x40020400

                          AREA ||i.DFU_Button_Read||, CODE, READONLY, ALIGN=2

                  DFU_Button_Read PROC
;;;184    *******************************************************************************/
;;;185    uint8_t DFU_Button_Read (void)
000000  f44f5100          MOV      r1,#0x2000
;;;186    {
;;;187    	return GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);
000004  4801              LDR      r0,|L2.12|
000006  f7ffbffe          B.W      GPIO_ReadInputDataBit
;;;188    }
;;;189    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x40020400

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;104    *******************************************************************************/
;;;105    void Enter_LowPowerMode(void)
000000  4901              LDR      r1,|L3.8|
;;;106    {
;;;107    	/* Set the device state to suspend */
;;;108    	bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;109    }
000006  4770              BX       lr
;;;110    
                          ENDP

                  |L3.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;236    *******************************************************************************/
;;;237    void Get_SerialNum(void)
000000  4809              LDR      r0,|L4.40|
;;;238    {
000002  b510              PUSH     {r4,lr}
;;;239    	uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;240    
;;;241    	Device_Serial0 = *(uint32_t*)ID1;
000004  e9d01414          LDRD     r1,r4,[r0,#0x50]
;;;242    	Device_Serial1 = *(uint32_t*)ID2;
;;;243    	Device_Serial2 = *(uint32_t*)ID3;   
000008  6e40              LDR      r0,[r0,#0x64]
;;;244    
;;;245    	Device_Serial0 += Device_Serial2;
00000a  1808              ADDS     r0,r1,r0
00000c  d00b              BEQ      |L4.38|
;;;246    
;;;247    	if (Device_Serial0 != 0)
;;;248    	{
;;;249    		IntToUnicode (Device_Serial0, &DFU_StringSerial[2] , 8);
00000e  2208              MOVS     r2,#8
000010  4906              LDR      r1,|L4.44|
000012  f7fffffe          BL       IntToUnicode
;;;250    		IntToUnicode (Device_Serial1, &DFU_StringSerial[18], 4);
000016  4905              LDR      r1,|L4.44|
000018  4620              MOV      r0,r4
00001a  2204              MOVS     r2,#4
00001c  e8bd4010          POP      {r4,lr}
000020  3110              ADDS     r1,r1,#0x10
000022  f7ffbffe          B.W      IntToUnicode
                  |L4.38|
;;;251    	}
;;;252    }
000026  bd10              POP      {r4,pc}
;;;253    
                          ENDP

                  |L4.40|
                          DCD      0x1ff80000
                  |L4.44|
                          DCD      DFU_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=2

                  IntToUnicode PROC
;;;260    *******************************************************************************/
;;;261    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;262    {
;;;263      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;264      
;;;265      for( idx = 0 ; idx < len ; idx ++)
;;;266      {
;;;267        if( ((value >> 28)) < 0xA )
000004  240a              MOVS     r4,#0xa
;;;268        {
;;;269          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2530              MOVS     r5,#0x30
;;;270        }
;;;271        else
;;;272        {
;;;273          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  2637              MOVS     r6,#0x37
00000a  461f              MOV      r7,r3
00000c  e011              B        |L5.50|
00000e  bf00              NOP                            ;267
                  |L5.16|
000010  ebb47f10          CMP      r4,r0,LSR #28         ;267
000014  d902              BLS      |L5.28|
000016  eb057c10          ADD      r12,r5,r0,LSR #28     ;269
00001a  e001              B        |L5.32|
                  |L5.28|
00001c  eb067c10          ADD      r12,r6,r0,LSR #28
                  |L5.32|
000020  f801c013          STRB     r12,[r1,r3,LSL #1]
;;;274        }
;;;275        
;;;276        value = value << 4;
;;;277        
;;;278        pbuf[ 2* idx + 1] = 0;
000024  eb010c43          ADD      r12,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;276
00002a  1c5b              ADDS     r3,r3,#1
00002c  f88c7001          STRB     r7,[r12,#1]
000030  b2db              UXTB     r3,r3                 ;265
                  |L5.50|
000032  4293              CMP      r3,r2                 ;265
000034  d3ec              BCC      |L5.16|
;;;279      }
;;;280    }
000036  bdf0              POP      {r4-r7,pc}
;;;281    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;117    *******************************************************************************/
;;;118    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L6.20|
;;;119    {
;;;120    	DEVICE_INFO *pInfo = &Device_Info;
;;;121    
;;;122    	/* Set the device state to the correct state */
;;;123    	if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;124    	{
;;;125    		/* Device configured */
;;;126    		bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L6.24|
000006  b109              CBZ      r1,|L6.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L6.14|
                  |L6.12|
;;;127    	}
;;;128    	else
;;;129    	{
;;;130    		bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L6.14|
00000e  6001              STR      r1,[r0,#0]  ; bDeviceState
;;;131    	}
;;;132    	
;;;133    	/*Enable SystemCoreClock*/
;;;134    	SystemInit();
000010  f7ffbffe          B.W      SystemInit
;;;135    }
;;;136    
                          ENDP

                  |L6.20|
                          DCD      Device_Info
                  |L6.24|
                          DCD      bDeviceState

                          AREA ||i.Reset_Device||, CODE, READONLY, ALIGN=2

                  Reset_Device PROC
;;;223    *******************************************************************************/
;;;224    void Reset_Device(void)
000000  2000              MOVS     r0,#0
;;;225    {
;;;226    	USB_Cable_Config(DISABLE);
000002  f7fffffe          BL       USB_Cable_Config
000006  f3bf8f4f          DSB      
00000a  4805              LDR      r0,|L7.32|
00000c  6801              LDR      r1,[r0,#0]
00000e  4a05              LDR      r2,|L7.36|
000010  f40161e0          AND      r1,r1,#0x700
000014  4311              ORRS     r1,r1,r2
000016  6001              STR      r1,[r0,#0]
000018  f3bf8f4f          DSB      
                  |L7.28|
00001c  e7fe              B        |L7.28|
;;;227    	NVIC_SystemReset();
;;;228    }
;;;229    
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0xe000ed0c
                  |L7.36|
                          DCD      0x05fa0004

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;54     *******************************************************************************/
;;;55     void Set_System(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;56     {
;;;57     	//不需要USB_CTRL, 在此设置使不发挥作用
;;;58     	GPIO_InitTypeDef GPIO_InitStructure;
;;;59     	
;;;60     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
000002  2101              MOVS     r1,#1
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;61         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00000a  2040              MOVS     r0,#0x40
;;;62         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
00000c  9000              STR      r0,[sp,#0]
00000e  2003              MOVS     r0,#3
000010  f88d0005          STRB     r0,[sp,#5]
;;;63         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000014  2401              MOVS     r4,#1
000016  f88d4004          STRB     r4,[sp,#4]
;;;64     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001a  2000              MOVS     r0,#0
00001c  f88d0006          STRB     r0,[sp,#6]
;;;65     	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
;;;66         GPIO_Init(GPIOC, &GPIO_InitStructure);
000020  4d11              LDR      r5,|L8.104|
000022  f88d0007          STRB     r0,[sp,#7]            ;65
000026  4669              MOV      r1,sp
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       GPIO_Init
;;;67     	GPIO_SetBits(GPIOC, GPIO_Pin_6);
00002e  2140              MOVS     r1,#0x40
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       GPIO_SetBits
;;;68     	
;;;69     	/* Enable the SYSCFG module clock */
;;;70     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000036  2101              MOVS     r1,#1
000038  4608              MOV      r0,r1
00003a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;71        
;;;72     	FLASH_Unlock();
00003e  f7fffffe          BL       FLASH_Unlock
;;;73       
;;;74     	/* Init the media interface */
;;;75     	MAL_Init();
000042  f7fffffe          BL       MAL_Init
;;;76     	USB_Cable_Config(ENABLE);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       USB_Cable_Config
;;;77     
;;;78     	/* Configure the EXTI line 18 connected internally to the USB IP */
;;;79     	EXTI_ClearITPendingBit(EXTI_Line18);
00004c  04a5              LSLS     r5,r4,#18
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       EXTI_ClearITPendingBit
;;;80     	EXTI_InitStructure.EXTI_Line = EXTI_Line18; 
000054  4905              LDR      r1,|L8.108|
;;;81     	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000056  2008              MOVS     r0,#8
000058  600d              STR      r5,[r1,#0]  ; EXTI_InitStructure
00005a  7148              STRB     r0,[r1,#5]
;;;82     	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00005c  718c              STRB     r4,[r1,#6]
;;;83     	EXTI_Init(&EXTI_InitStructure);
00005e  4608              MOV      r0,r1
000060  f7fffffe          BL       EXTI_Init
;;;84     }
000064  bd7c              POP      {r2-r6,pc}
;;;85     
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      0x40020800
                  |L8.108|
                          DCD      ||area_number.15||

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;92     *******************************************************************************/
;;;93     void Set_USBClock(void)
000000  2101              MOVS     r1,#1
;;;94     {
;;;95     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000002  05c8              LSLS     r0,r1,#23
000004  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;96     }
;;;97     
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=1

                  USB_Cable_Config PROC
;;;143    *******************************************************************************/
;;;144    void USB_Cable_Config (FunctionalState NewState)
000000  b100              CBZ      r0,|L10.4|
;;;145    {
;;;146    	if (NewState != DISABLE)
;;;147    	{
;;;148    		STM32L15_USB_CONNECT;
000002  2001              MOVS     r0,#1
                  |L10.4|
;;;149    	}
;;;150    	else
;;;151    	{
;;;152    		STM32L15_USB_DISCONNECT;
000004  f7ffbffe          B.W      SYSCFG_USBPuCmd
;;;153    	}  
;;;154    }
;;;155    
                          ENDP


                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;196    *******************************************************************************/
;;;197    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;198    {
;;;199    	NVIC_InitTypeDef NVIC_InitStructure;
;;;200    
;;;201    	/* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;202    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;203    
;;;204    	NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;205    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;206    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;207    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2501              MOVS     r5,#1
00001e  f88d5003          STRB     r5,[sp,#3]
;;;208    	NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;209    
;;;210    	/* Enable the USB Wake-up interrupt */
;;;211    	NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;212    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  f88d4001          STRB     r4,[sp,#1]
;;;213    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  f88d5003          STRB     r5,[sp,#3]
;;;214    	NVIC_Init(&NVIC_InitStructure);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       NVIC_Init
;;;215    }
00003c  bd38              POP      {r3-r5,pc}
;;;216    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\User\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 114 "..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 128
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
