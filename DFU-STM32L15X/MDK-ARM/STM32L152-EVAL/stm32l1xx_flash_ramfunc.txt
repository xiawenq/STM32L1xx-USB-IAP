; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_flash_ramfunc.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_flash_ramfunc.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\utility -I..\User\inc -I..\Libraries\CMSIS\Include -I..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I"E:\my code\IAP\DFU-STM32L15X\MDK-ARM\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32L1xx_DFP\1.0.2\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL --omf_browse=.\stm32l152-eval\stm32l1xx_flash_ramfunc.crf ..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_flash_ramfunc.c]
                          THUMB

                          AREA ||i.DATA_EEPROM_EraseDoubleWord||, CODE, READONLY, ALIGN=2

                  DATA_EEPROM_EraseDoubleWord PROC
;;;371    
;;;372    __RAM_FUNC DATA_EEPROM_EraseDoubleWord(uint32_t Address)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;373    {
;;;374      FLASH_Status status = FLASH_COMPLETE;
;;;375      
;;;376      /* Set the DISMCYCINT[0] bit in the Auxillary Control Register (0xE000E008) 
;;;377         This bit prevents the interruption of multicycle instructions and therefore 
;;;378         will increase the interrupt latency. of Cortex-M3. */
;;;379      SCnSCB->ACTLR |= SCnSCB_ACTLR_DISMCYCINT_Msk;
000004  f04f26e0          MOV      r6,#0xe000e000
000008  4605              MOV      r5,r0                 ;373
00000a  68b0              LDR      r0,[r6,#8]
00000c  f0400001          ORR      r0,r0,#1
000010  60b0              STR      r0,[r6,#8]
;;;380        
;;;381      /* Wait for last operation to be completed */
;;;382      status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000012  f44f4700          MOV      r7,#0x8000
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       WaitForLastOperation
;;;383      
;;;384      if(status == FLASH_COMPLETE)
00001c  2804              CMP      r0,#4
00001e  d116              BNE      |L1.78|
;;;385      {
;;;386        /* If the previous operation is completed, proceed to erase the next double word */
;;;387        /* Set the ERASE bit */
;;;388        FLASH->PECR |= FLASH_PECR_ERASE;
000020  4c0e              LDR      r4,|L1.92|
000022  6820              LDR      r0,[r4,#0]
000024  f4407000          ORR      r0,r0,#0x200
000028  6020              STR      r0,[r4,#0]
;;;389    
;;;390        /* Set DATA bit */
;;;391        FLASH->PECR |= FLASH_PECR_DATA;
00002a  6820              LDR      r0,[r4,#0]
00002c  f0400010          ORR      r0,r0,#0x10
000030  6020              STR      r0,[r4,#0]
;;;392       
;;;393        /* Write 00000000h to the 2 words to erase */
;;;394        *(__IO uint32_t *)Address = 0x00000000;
000032  2000              MOVS     r0,#0
000034  6028              STR      r0,[r5,#0]
;;;395        Address += 4;
;;;396        *(__IO uint32_t *)Address = 0x00000000;
000036  6068              STR      r0,[r5,#4]
;;;397       
;;;398        /* Wait for last operation to be completed */
;;;399        status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       WaitForLastOperation
;;;400        
;;;401        /* If the erase operation is completed, disable the ERASE and DATA bits */
;;;402        FLASH->PECR &= (uint32_t)(~FLASH_PECR_ERASE);
00003e  6821              LDR      r1,[r4,#0]
000040  f4217100          BIC      r1,r1,#0x200
000044  6021              STR      r1,[r4,#0]
;;;403        FLASH->PECR &= (uint32_t)(~FLASH_PECR_DATA);
000046  6821              LDR      r1,[r4,#0]
000048  f0210110          BIC      r1,r1,#0x10
00004c  6021              STR      r1,[r4,#0]
                  |L1.78|
;;;404      }  
;;;405      
;;;406      SCnSCB->ACTLR &= ~SCnSCB_ACTLR_DISMCYCINT_Msk;
00004e  68b1              LDR      r1,[r6,#8]
000050  f0210101          BIC      r1,r1,#1
000054  60b1              STR      r1,[r6,#8]
;;;407        
;;;408      /* Return the erase status */
;;;409      return status;
;;;410    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;411    
                          ENDP

00005a  0000              DCW      0x0000
                  |L1.92|
                          DCD      0x40023c04

                          AREA ||i.DATA_EEPROM_ProgramDoubleWord||, CODE, READONLY, ALIGN=2

                  DATA_EEPROM_ProgramDoubleWord PROC
;;;430      */ 
;;;431    __RAM_FUNC DATA_EEPROM_ProgramDoubleWord(uint32_t Address, uint64_t Data)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;432    {
;;;433      FLASH_Status status = FLASH_COMPLETE;
;;;434    
;;;435      /* Set the DISMCYCINT[0] bit in the Auxillary Control Register (0xE000E008) 
;;;436         This bit prevents the interruption of multicycle instructions and therefore 
;;;437         will increase the interrupt latency. of Cortex-M3. */
;;;438      SCnSCB->ACTLR |= SCnSCB_ACTLR_DISMCYCINT_Msk;
000004  f04f26e0          MOV      r6,#0xe000e000
000008  4605              MOV      r5,r0                 ;432
00000a  68b0              LDR      r0,[r6,#8]
00000c  4617              MOV      r7,r2                 ;432
00000e  4698              MOV      r8,r3                 ;432
000010  f0400001          ORR      r0,r0,#1
000014  60b0              STR      r0,[r6,#8]
;;;439        
;;;440      /* Wait for last operation to be completed */
;;;441      status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000016  f44f4900          MOV      r9,#0x8000
00001a  4648              MOV      r0,r9
00001c  f7fffffe          BL       WaitForLastOperation
;;;442      
;;;443      if(status == FLASH_COMPLETE)
000020  2804              CMP      r0,#4
000022  d116              BNE      |L2.82|
;;;444      {
;;;445        /* If the previous operation is completed, proceed to program the new data*/
;;;446        FLASH->PECR |= FLASH_PECR_FPRG;
000024  4c0e              LDR      r4,|L2.96|
000026  6820              LDR      r0,[r4,#0]
000028  f4406080          ORR      r0,r0,#0x400
00002c  6020              STR      r0,[r4,#0]
;;;447        FLASH->PECR |= FLASH_PECR_DATA;
00002e  6820              LDR      r0,[r4,#0]
000030  f0400010          ORR      r0,r0,#0x10
000034  6020              STR      r0,[r4,#0]
;;;448        
;;;449        /* Write the 2 words */  
;;;450         *(__IO uint32_t *)Address = (uint32_t) Data;
000036  602f              STR      r7,[r5,#0]
;;;451         Address += 4;
;;;452         *(__IO uint32_t *)Address = (uint32_t) (Data >> 32);
000038  f8c58004          STR      r8,[r5,#4]
;;;453        
;;;454        /* Wait for last operation to be completed */
;;;455        status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       WaitForLastOperation
;;;456        
;;;457        /* If the write operation is completed, disable the FPRG and DATA bits */
;;;458        FLASH->PECR &= (uint32_t)(~FLASH_PECR_FPRG);
000042  6821              LDR      r1,[r4,#0]
000044  f4216180          BIC      r1,r1,#0x400
000048  6021              STR      r1,[r4,#0]
;;;459        FLASH->PECR &= (uint32_t)(~FLASH_PECR_DATA);     
00004a  6821              LDR      r1,[r4,#0]
00004c  f0210110          BIC      r1,r1,#0x10
000050  6021              STR      r1,[r4,#0]
                  |L2.82|
;;;460      }
;;;461      
;;;462      SCnSCB->ACTLR &= ~SCnSCB_ACTLR_DISMCYCINT_Msk;
000052  68b1              LDR      r1,[r6,#8]
000054  f0210101          BIC      r1,r1,#1
000058  60b1              STR      r1,[r6,#8]
;;;463        
;;;464      /* Return the Write Status */
;;;465      return status;
;;;466    }
00005a  e8bd87f0          POP      {r4-r10,pc}
;;;467    
                          ENDP

00005e  0000              DCW      0x0000
                  |L2.96|
                          DCD      0x40023c04

                          AREA ||i.FLASH_EraseParallelPage||, CODE, READONLY, ALIGN=2

                  FLASH_EraseParallelPage PROC
;;;158      */
;;;159    FLASH_Status FLASH_EraseParallelPage(uint32_t Page_Address1, uint32_t Page_Address2)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;160    {
000004  4606              MOV      r6,r0
;;;161      FLASH_Status status = FLASH_COMPLETE;
;;;162    
;;;163      /* Wait for last operation to be completed */
;;;164      status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000006  f44f4700          MOV      r7,#0x8000
00000a  460d              MOV      r5,r1                 ;160
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       WaitForLastOperation
;;;165      
;;;166      if(status == FLASH_COMPLETE)
000012  2804              CMP      r0,#4
000014  d11e              BNE      |L3.84|
;;;167      {
;;;168        /* If the previous operation is completed, proceed to erase the page */
;;;169    
;;;170        /* Set the PARALLBANK bit */
;;;171        FLASH->PECR |= FLASH_PECR_PARALLBANK;
000016  4c10              LDR      r4,|L3.88|
000018  6820              LDR      r0,[r4,#0]
00001a  f4404000          ORR      r0,r0,#0x8000
00001e  6020              STR      r0,[r4,#0]
;;;172        
;;;173        /* Set the ERASE bit */
;;;174        FLASH->PECR |= FLASH_PECR_ERASE;
000020  6820              LDR      r0,[r4,#0]
000022  f4407000          ORR      r0,r0,#0x200
000026  6020              STR      r0,[r4,#0]
;;;175    
;;;176        /* Set PROG bit */
;;;177        FLASH->PECR |= FLASH_PECR_PROG;
000028  6820              LDR      r0,[r4,#0]
00002a  f0400008          ORR      r0,r0,#8
00002e  6020              STR      r0,[r4,#0]
;;;178      
;;;179        /* Write 00000000h to the first word of the first program page to erase */
;;;180        *(__IO uint32_t *)Page_Address1 = 0x00000000;
000030  2000              MOVS     r0,#0
000032  6030              STR      r0,[r6,#0]
;;;181        /* Write 00000000h to the first word of the second program page to erase */    
;;;182        *(__IO uint32_t *)Page_Address2 = 0x00000000;    
000034  6028              STR      r0,[r5,#0]
;;;183     
;;;184        /* Wait for last operation to be completed */
;;;185        status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       WaitForLastOperation
;;;186    
;;;187        /* If the erase operation is completed, disable the ERASE, PROG and PARALLBANK bits */
;;;188        FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
00003c  6821              LDR      r1,[r4,#0]
00003e  f0210108          BIC      r1,r1,#8
000042  6021              STR      r1,[r4,#0]
;;;189        FLASH->PECR &= (uint32_t)(~FLASH_PECR_ERASE);
000044  6821              LDR      r1,[r4,#0]
000046  f4217100          BIC      r1,r1,#0x200
00004a  6021              STR      r1,[r4,#0]
;;;190        FLASH->PECR &= (uint32_t)(~FLASH_PECR_PARALLBANK);   
00004c  6821              LDR      r1,[r4,#0]
00004e  f4214100          BIC      r1,r1,#0x8000
000052  6021              STR      r1,[r4,#0]
                  |L3.84|
;;;191      }     
;;;192      /* Return the Erase Status */
;;;193      return status;
;;;194    }
000054  e8bd81f0          POP      {r4-r8,pc}
;;;195    
                          ENDP

                  |L3.88|
                          DCD      0x40023c04

                          AREA ||i.FLASH_ProgramHalfPage||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfPage PROC
;;;220      */
;;;221    __RAM_FUNC FLASH_ProgramHalfPage(uint32_t Address, uint32_t* pBuffer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;222    {
;;;223      uint32_t count = 0; 
;;;224       
;;;225      FLASH_Status status = FLASH_COMPLETE;
;;;226    
;;;227      /* Set the DISMCYCINT[0] bit in the Auxillary Control Register (0xE000E008) 
;;;228         This bit prevents the interruption of multicycle instructions and therefore 
;;;229         will increase the interrupt latency. of Cortex-M3. */
;;;230      SCnSCB->ACTLR |= SCnSCB_ACTLR_DISMCYCINT_Msk;
000004  f04f28e0          MOV      r8,#0xe000e000
000008  460e              MOV      r6,r1                 ;222
00000a  f8d81008          LDR      r1,[r8,#8]
00000e  4607              MOV      r7,r0                 ;222
000010  2500              MOVS     r5,#0                 ;223
000012  f0410101          ORR      r1,r1,#1
000016  f8c81008          STR      r1,[r8,#8]
;;;231      
;;;232      /* Wait for last operation to be completed */
;;;233      status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
00001a  f44f4900          MOV      r9,#0x8000
00001e  4648              MOV      r0,r9
000020  f7fffffe          BL       WaitForLastOperation
;;;234      
;;;235      if(status == FLASH_COMPLETE)
000024  2804              CMP      r0,#4
000026  d119              BNE      |L4.92|
;;;236      {
;;;237        /* if the previous operation is completed, proceed to program the new  
;;;238        half page */
;;;239        FLASH->PECR |= FLASH_PECR_FPRG;
000028  4c10              LDR      r4,|L4.108|
00002a  6820              LDR      r0,[r4,#0]
00002c  f4406080          ORR      r0,r0,#0x400
000030  6020              STR      r0,[r4,#0]
;;;240        FLASH->PECR |= FLASH_PECR_PROG;
000032  6820              LDR      r0,[r4,#0]
000034  f0400008          ORR      r0,r0,#8
000038  6020              STR      r0,[r4,#0]
                  |L4.58|
;;;241        
;;;242        /* Write one half page directly with 32 different words */
;;;243        while(count < 32)
;;;244        {
;;;245          *(__IO uint32_t*) (Address + (4 * count)) = *(pBuffer++);
00003a  ce01              LDM      r6!,{r0}
00003c  f8470025          STR      r0,[r7,r5,LSL #2]
000040  1c6d              ADDS     r5,r5,#1
000042  2d20              CMP      r5,#0x20              ;243
;;;246          count ++;  
000044  d3f9              BCC      |L4.58|
;;;247        }
;;;248        /* Wait for last operation to be completed */
;;;249        status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
000046  4648              MOV      r0,r9
000048  f7fffffe          BL       WaitForLastOperation
;;;250     
;;;251        /* if the write operation is completed, disable the PROG and FPRG bits */
;;;252        FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
00004c  6821              LDR      r1,[r4,#0]
00004e  f0210108          BIC      r1,r1,#8
000052  6021              STR      r1,[r4,#0]
;;;253        FLASH->PECR &= (uint32_t)(~FLASH_PECR_FPRG);
000054  6821              LDR      r1,[r4,#0]
000056  f4216180          BIC      r1,r1,#0x400
00005a  6021              STR      r1,[r4,#0]
                  |L4.92|
;;;254      }
;;;255    
;;;256      SCnSCB->ACTLR &= ~SCnSCB_ACTLR_DISMCYCINT_Msk;
00005c  f8d82008          LDR      r2,[r8,#8]
000060  f0220201          BIC      r2,r2,#1
000064  f8c82008          STR      r2,[r8,#8]
;;;257        
;;;258      /* Return the Write Status */
;;;259      return status;
;;;260    }
000068  e8bd87f0          POP      {r4-r10,pc}
;;;261    
                          ENDP

                  |L4.108|
                          DCD      0x40023c04

                          AREA ||i.FLASH_ProgramParallelHalfPage||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramParallelHalfPage PROC
;;;292      */
;;;293    __RAM_FUNC FLASH_ProgramParallelHalfPage(uint32_t Address1, uint32_t* pBuffer1, uint32_t Address2, uint32_t* pBuffer2)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;294    {
;;;295      uint32_t count = 0; 
;;;296       
;;;297      FLASH_Status status = FLASH_COMPLETE;
;;;298    
;;;299      /* Set the DISMCYCINT[0] bit in the Auxillary Control Register (0xE000E008) 
;;;300         This bit prevents the interruption of multicycle instructions and therefore 
;;;301         will increase the interrupt latency. of Cortex-M3. */
;;;302      SCnSCB->ACTLR |= SCnSCB_ACTLR_DISMCYCINT_Msk;
000004  f04f2ae0          MOV      r10,#0xe000e000
000008  460e              MOV      r6,r1                 ;294
00000a  f8da1008          LDR      r1,[r10,#8]
00000e  461d              MOV      r5,r3                 ;294
000010  4617              MOV      r7,r2                 ;294
000012  4680              MOV      r8,r0                 ;294
000014  2400              MOVS     r4,#0                 ;295
000016  f0410101          ORR      r1,r1,#1
00001a  f8ca1008          STR      r1,[r10,#8]
;;;303    
;;;304      /* Wait for last operation to be completed */
;;;305      status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
00001e  f44f4b00          MOV      r11,#0x8000
000022  4658              MOV      r0,r11
000024  f7fffffe          BL       WaitForLastOperation
;;;306      
;;;307      if(status == FLASH_COMPLETE)
000028  2804              CMP      r0,#4
00002a  d135              BNE      |L5.152|
;;;308      {
;;;309        /* If the previous operation is completed, proceed to program the new  
;;;310           half page */
;;;311        FLASH->PECR |= FLASH_PECR_PARALLBANK;
00002c  f8df9078          LDR      r9,|L5.168|
000030  f8d91000          LDR      r1,[r9,#0]
000034  f4414100          ORR      r1,r1,#0x8000
000038  f8c91000          STR      r1,[r9,#0]
;;;312        FLASH->PECR |= FLASH_PECR_FPRG;
00003c  f8d91000          LDR      r1,[r9,#0]
000040  f4416180          ORR      r1,r1,#0x400
000044  f8c91000          STR      r1,[r9,#0]
;;;313        FLASH->PECR |= FLASH_PECR_PROG;
000048  f8d91000          LDR      r1,[r9,#0]
00004c  f0410108          ORR      r1,r1,#8
000050  f8c91000          STR      r1,[r9,#0]
                  |L5.84|
;;;314        
;;;315        /* Write the first half page directly with 32 different words */
;;;316        while(count < 32)
;;;317        {
;;;318          *(__IO uint32_t*) (Address1 + (4 * count)) = *(pBuffer1++);
000054  ce02              LDM      r6!,{r1}
000056  f8481024          STR      r1,[r8,r4,LSL #2]
00005a  1c64              ADDS     r4,r4,#1
00005c  2c20              CMP      r4,#0x20              ;316
;;;319          count ++;  
00005e  d3f9              BCC      |L5.84|
;;;320        }
;;;321        count = 0;
000060  2000              MOVS     r0,#0
                  |L5.98|
;;;322        /* Write the second half page directly with 32 different words */
;;;323        while(count < 32)
;;;324        {
;;;325          *(__IO uint32_t*) (Address2 + (4 * count)) = *(pBuffer2++);
000062  cd02              LDM      r5!,{r1}
000064  f8471020          STR      r1,[r7,r0,LSL #2]
000068  1c40              ADDS     r0,r0,#1
00006a  2820              CMP      r0,#0x20              ;323
00006c  d3f9              BCC      |L5.98|
;;;326          count ++;  
;;;327        }
;;;328        /* Wait for last operation to be completed */
;;;329        status = WaitForLastOperation(FLASH_ER_PRG_TIMEOUT);
00006e  4658              MOV      r0,r11
000070  f7fffffe          BL       WaitForLastOperation
;;;330     
;;;331        /* if the write operation is completed, disable the PROG, FPRG and PARALLBANK bits */
;;;332        FLASH->PECR &= (uint32_t)(~FLASH_PECR_PROG);
000074  f8d92000          LDR      r2,[r9,#0]
000078  f0220208          BIC      r2,r2,#8
00007c  f8c92000          STR      r2,[r9,#0]
;;;333        FLASH->PECR &= (uint32_t)(~FLASH_PECR_FPRG);
000080  f8d92000          LDR      r2,[r9,#0]
000084  f4226280          BIC      r2,r2,#0x400
000088  f8c92000          STR      r2,[r9,#0]
;;;334        FLASH->PECR &= (uint32_t)(~FLASH_PECR_PARALLBANK);
00008c  f8d92000          LDR      r2,[r9,#0]
000090  f4224200          BIC      r2,r2,#0x8000
000094  f8c92000          STR      r2,[r9,#0]
                  |L5.152|
;;;335      }
;;;336    
;;;337      SCnSCB->ACTLR &= ~SCnSCB_ACTLR_DISMCYCINT_Msk;
000098  f8da2008          LDR      r2,[r10,#8]
00009c  f0220201          BIC      r2,r2,#1
0000a0  f8ca2008          STR      r2,[r10,#8]
;;;338        
;;;339      /* Return the Write Status */
;;;340      return status;
;;;341    }
0000a4  e8bd9ff0          POP      {r4-r12,pc}
;;;342    
                          ENDP

                  |L5.168|
                          DCD      0x40023c04

                          AREA ||i.FLASH_RUNPowerDownCmd||, CODE, READONLY, ALIGN=2

                  FLASH_RUNPowerDownCmd PROC
;;;101      */
;;;102    __RAM_FUNC FLASH_RUNPowerDownCmd(FunctionalState NewState)
000000  0002              MOVS     r2,r0
;;;103    {
;;;104      FLASH_Status status = FLASH_COMPLETE;
;;;105     
;;;106      if (NewState != DISABLE)
;;;107      {
;;;108         /* Unlock the RUN_PD bit */
;;;109         FLASH->PDKEYR = FLASH_PDKEY1;
;;;110         FLASH->PDKEYR = FLASH_PDKEY2;
;;;111         
;;;112         /* Set the RUN_PD bit in  FLASH_ACR register to put Flash in power down mode */
;;;113         FLASH->ACR |= (uint32_t)FLASH_ACR_RUN_PD;
000002  490c              LDR      r1,|L6.52|
000004  f04f0004          MOV      r0,#4                 ;104
000008  d00e              BEQ      |L6.40|
00000a  4a0a              LDR      r2,|L6.52|
00000c  4b0a              LDR      r3,|L6.56|
00000e  3208              ADDS     r2,r2,#8              ;109
000010  6013              STR      r3,[r2,#0]            ;109
000012  4b0a              LDR      r3,|L6.60|
000014  6013              STR      r3,[r2,#0]            ;110
000016  680a              LDR      r2,[r1,#0]
000018  f0420210          ORR      r2,r2,#0x10
00001c  600a              STR      r2,[r1,#0]
;;;114    
;;;115         if((FLASH->ACR & FLASH_ACR_RUN_PD) != FLASH_ACR_RUN_PD)
00001e  6809              LDR      r1,[r1,#0]
000020  06c9              LSLS     r1,r1,#27
000022  d400              BMI      |L6.38|
;;;116         {
;;;117           status = FLASH_ERROR_PROGRAM;
000024  2003              MOVS     r0,#3
                  |L6.38|
;;;118         }
;;;119      }
;;;120      else
;;;121      {
;;;122        /* Clear the RUN_PD bit in  FLASH_ACR register to put Flash in idle  mode */
;;;123        FLASH->ACR &= (uint32_t)(~(uint32_t)FLASH_ACR_RUN_PD);
;;;124      }
;;;125    
;;;126      /* Return the Write Status */
;;;127      return status;  
;;;128    }
000026  4770              BX       lr
                  |L6.40|
000028  680a              LDR      r2,[r1,#0]            ;123
00002a  f0220210          BIC      r2,r2,#0x10           ;123
00002e  600a              STR      r2,[r1,#0]            ;123
000030  4770              BX       lr
;;;129    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      0x40023c00
                  |L6.56|
                          DCD      0x04152637
                  |L6.60|
                          DCD      0xfafbfcfd

                          AREA ||i.GetStatus||, CODE, READONLY, ALIGN=2

                  GetStatus PROC
;;;477      */
;;;478    static __RAM_FUNC GetStatus(void)
000000  4908              LDR      r1,|L7.36|
;;;479    {
;;;480      FLASH_Status FLASHstatus = FLASH_COMPLETE;
000002  2004              MOVS     r0,#4
;;;481      
;;;482      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000004  680a              LDR      r2,[r1,#0]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L7.14|
;;;483      {
;;;484        FLASHstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;485      }
;;;486      else 
;;;487      {  
;;;488        if((FLASH->SR & (uint32_t)FLASH_FLAG_WRPERR)!= (uint32_t)0x00)
;;;489        { 
;;;490          FLASHstatus = FLASH_ERROR_WRP;
;;;491        }
;;;492        else 
;;;493        {
;;;494          if((FLASH->SR & (uint32_t)0x1E00) != (uint32_t)0x00)
;;;495          {
;;;496            FLASHstatus = FLASH_ERROR_PROGRAM; 
;;;497          }
;;;498          else
;;;499          {
;;;500            FLASHstatus = FLASH_COMPLETE;
;;;501          }
;;;502        }
;;;503      }
;;;504      /* Return the FLASH Status */
;;;505      return FLASHstatus;
;;;506    }
00000c  4770              BX       lr
                  |L7.14|
00000e  680a              LDR      r2,[r1,#0]            ;488
000010  05d2              LSLS     r2,r2,#23             ;488
000012  d501              BPL      |L7.24|
000014  2002              MOVS     r0,#2                 ;490
                  |L7.22|
000016  4770              BX       lr
                  |L7.24|
000018  6809              LDR      r1,[r1,#0]            ;494
00001a  f4115ff0          TST      r1,#0x1e00            ;494
00001e  d0fa              BEQ      |L7.22|
000020  2003              MOVS     r0,#3                 ;496
000022  4770              BX       lr
;;;507    
                          ENDP

                  |L7.36|
                          DCD      0x40023c18

                          AREA ||i.WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  WaitForLastOperation PROC
;;;514      */
;;;515    static __RAM_FUNC  WaitForLastOperation(uint32_t Timeout)
000000  b538              PUSH     {r3-r5,lr}
;;;516    { 
000002  4604              MOV      r4,r0
;;;517      __IO FLASH_Status status = FLASH_COMPLETE;
000004  2004              MOVS     r0,#4
000006  f88d0000          STRB     r0,[sp,#0]
;;;518       
;;;519      /* Check for the FLASH Status */
;;;520      status = GetStatus();
00000a  f7fffffe          BL       GetStatus
00000e  f88d0000          STRB     r0,[sp,#0]
;;;521      
;;;522      /* Wait for a FLASH operation to complete or a TIMEOUT to occur */
;;;523      while((status == FLASH_BUSY) && (Timeout != 0x00))
000012  e004              B        |L8.30|
                  |L8.20|
;;;524      {
;;;525        status = GetStatus();
000014  f7fffffe          BL       GetStatus
000018  f88d0000          STRB     r0,[sp,#0]
00001c  1e64              SUBS     r4,r4,#1
                  |L8.30|
00001e  f89d0000          LDRB     r0,[sp,#0]            ;523
000022  2801              CMP      r0,#1                 ;523
000024  d001              BEQ      |L8.42|
;;;526        Timeout--;
;;;527      }
;;;528      
;;;529      if(Timeout == 0x00 )
000026  b114              CBZ      r4,|L8.46|
000028  e004              B        |L8.52|
                  |L8.42|
00002a  2c00              CMP      r4,#0                 ;523
00002c  d1f2              BNE      |L8.20|
                  |L8.46|
;;;530      {
;;;531        status = FLASH_TIMEOUT;
00002e  2005              MOVS     r0,#5
000030  f88d0000          STRB     r0,[sp,#0]
                  |L8.52|
;;;532      }
;;;533      /* Return the operation status */
;;;534      return status;
000034  f89d0000          LDRB     r0,[sp,#0]
;;;535    }
000038  bd38              POP      {r3-r5,pc}
;;;536    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_flash_ramfunc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_stm32l1xx_flash_ramfunc_c_5c93427a____REV16|
#line 114 "..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___25_stm32l1xx_flash_ramfunc_c_5c93427a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_stm32l1xx_flash_ramfunc_c_5c93427a____REVSH|
#line 128
|__asm___25_stm32l1xx_flash_ramfunc_c_5c93427a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
